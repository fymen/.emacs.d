#+OPTIONS: toc:4 h:4
#+TITLE: Emacs init configuration
* Package management
#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)

  (setq package-archives
      '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
        ("MELPA Stable" . "https://stable.melpa.org/packages/")
        ("MELPA"        . "https://melpa.org/packages/"))
      package-archive-priorities
      '(("GNU ELPA"     . 10)
        ("MELPA"        . 5)
        ("MELPA Stable" . 0)))
#+end_src
** Paradox
#+begin_src emacs-lisp
(use-package async
             :ensure t)
(use-package paradox
             :ensure t
             :config
             (setq paradox-execute-asynchronously t
                   ;; Avoid being ask for the token
                   paradox-github-token 0))

#+end_src
** Auto compile
#+begin_src emacs-lisp
(setq load-prefer-newer t)
(use-package auto-compile
 :ensure t
 :config
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1))
#+end_src
* General
** Basics
#+begin_src emacs-lisp
(setq-default tab-width 4                       ; Smaller tabs
              fill-column 79                    ; Maximum line width
              truncate-lines t                  ; Don't fold lines
              indent-tabs-mode nil              ; Use spaces instead of tabs
              split-width-threshold 80           ; Split Horizontally by default
              split-height-threshold 80        ; Split Horizontally by default
              frame-resize-pixelwise t          ; Fine-grained frame resize
              frame-title-format "%f %4 %b %Z %* %10 %I"
              x-select-enable-clipboard t
              x-select-enable-primary t
              auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere
(setq auto-revert-interval 1            ; Refresh buffers fast
      default-input-method "TeX"        ; Use TeX when toggling input method
      echo-keystrokes 0.1               ; Show keystrokes asap
      enable-recursive-minibuffers t    ; Allow recursive minibuffers
      frame-inhibit-implied-resize 1    ; Don't resize frame implicitly
      inhibit-startup-screen t          ; No splash screen please
      initial-scratch-message nil       ; Clean scratch buffer
      recentf-max-saved-items 10000     ; Show more recent files
      ring-bell-function 'ignore        ; Quiet
      scroll-margin 1                   ; Space between cursor and top/bottom
      sentence-end-double-space nil     ; No double space
      custom-file                       ; Customizations in a separate file
      (concat user-emacs-directory "custom.el"))

(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-x C-k") 'kill-region)
(global-set-key (kbd "C-x C-b") 'ibuffer-list-buffers)

(global-set-key (kbd "<f8>") 'eshell)
#+end_src
** GUI
#+begin_src emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
(when (functionp 'column-number-mode)
  (column-number-mode 1))
(when (functionp 'line-number-mode)
    (line-number-mode 1))
#+end_src
** Prettify symbols
#+begin_src emacs-lisp
(when (boundp 'global-prettify-symbols-mode)
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("lambda" . ?λ) prettify-symbols-alist)))
  (add-hook 'clojure-mode-hook
            (lambda ()
              (push '("fn" . ?ƒ) prettify-symbols-alist)))
  (global-prettify-symbols-mode +1))
#+end_src
** Color theme
#+begin_src emacs-lisp
  (use-package zenburn-theme
    :init)
  (load-theme 'zenburn t)
#+end_src
** OS related && fonts
#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  (set-face-attribute 'default nil)
  (set-face-attribute 'default nil :height 150))

(when (eq system-type 'gnu/linux)
  (if window-system
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
        (set-frame-font "Inconsolata 18")
        ;; (set-frame-font "CascadiaCode 16")
        ;; (set-frame-font "Firacode 15")
        (set-fontset-font (frame-parameter nil 'font)
                          charset (font-spec :family "WenQuanYi Micro Hei Mono"
                                             :size 16))
        ;; Default Browser
        (setq browse-url-browser-function 'browse-url-generic
              browse-url-generic-program "firefox"
              browse-url-new-window-flag t)
        )))
#+end_src
*** COMMENT Ligature
    #+begin_src emacs-lisp
    (use-package ligature
      :config
      ;; Enable the "www" ligature in every possible major mode
      (ligature-set-ligatures 't '("www"))
      ;; Enable traditional ligature support in eww-mode, if the
      ;; `variable-pitch' face supports it
      (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
      ;; Enable all Cascadia and Fira Code ligatures in programming modes
      (ligature-set-ligatures 'prog-mode
                            '(;; == === ==== => =| =>>=>=|=>==>> ==< =/=//=// =~
                              ;; =:= =!=
                              ("=" (rx (+ (or ">" "<" "|" "/" "~" ":" "!" "="))))
                              ;; ;; ;;;
                              (";" (rx (+ ";")))
                              ;; && &&&
                              ("&" (rx (+ "&")))
                              ;; !! !!! !. !: !!. != !== !~
                              ("!" (rx (+ (or "=" "!" "\." ":" "~"))))
                              ;; ?? ??? ?:  ?=  ?.
                              ("?" (rx (or ":" "=" "\." (+ "?"))))
                              ;; %% %%%
                              ("%" (rx (+ "%")))
                              ;; |> ||> |||> ||||> |] |} || ||| |-> ||-||
                              ;; |->>-||-<<-| |- |== ||=||
                              ;; |==>>==<<==<=>==//==/=!==:===>
                              ("|" (rx (+ (or ">" "<" "|" "/" ":" "!" "}" "\]"
                                              "-" "=" ))))
                              ;; \\ \\\ \/
                              ("\\" (rx (or "/" (+ "\\"))))
                              ;; ++ +++ ++++ +>
                              ("+" (rx (or ">" (+ "+"))))
                              ;; :: ::: :::: :> :< := :// ::=
                              (":" (rx (or ">" "<" "=" "//" ":=" (+ ":"))))
                              ;; // /// //// /\ /* /> /===:===!=//===>>==>==/
                              ("/" (rx (+ (or ">"  "<" "|" "/" "\\" "\*" ":" "!"
                                              "="))))
                              ;; .. ... .... .= .- .? ..= ..<
                              ("\." (rx (or "=" "-" "\?" "\.=" "\.<" (+ "\."))))
                              ;; -- --- ---- -~ -> ->> -| -|->-->>->--<<-|
                              ("-" (rx (+ (or ">" "<" "|" "~" "-"))))
                              ;; *> */ *)  ** *** ****
                              ("*" (rx (or ">" "/" ")" (+ "*"))))
                              ;; www wwww
                              ("w" (rx (+ "w")))
                              ;; <> <!-- <|> <: <~ <~> <~~ <+ <* <$ </  <+> <*>
                              ;; <$> </> <|  <||  <||| <|||| <- <-| <-<<-|-> <->>
                              ;; <<-> <= <=> <<==<<==>=|=>==/==//=!==:=>
                              ;; << <<< <<<<
                              ("<" (rx (+ (or "\+" "\*" "\$" "<" ">" ":" "~"  "!"
                                              "-"  "/" "|" "="))))
                              ;; >: >- >>- >--|-> >>-|-> >= >== >>== >=|=:=>>
                              ;; >> >>> >>>>
                              (">" (rx (+ (or ">" "<" "|" "/" ":" "=" "-"))))
                              ;; #: #= #! #( #? #[ #{ #_ #_( ## ### #####
                              ("#" (rx (or ":" "=" "!" "(" "\?" "\[" "{" "_(" "_"
                                           (+ "#"))))
                              ;; ~~ ~~~ ~=  ~-  ~@ ~> ~~>
                              ("~" (rx (or ">" "=" "-" "@" "~>" (+ "~"))))
                              ;; __ ___ ____ _|_ __|____|_
                              ("_" (rx (+ (or "_" "|"))))
                              ;; Fira code: 0xFF 0x12
                              ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))
                              ;; Fira code:
                              "Fl"  "Tl"  "fi"  "fj"  "fl"  "ft"
                              ;; The few not covered by the regexps.
                              "{|"  "[|"  "]#"  "(*"  "}#"  "$>"  "^="))
      ;; Enables ligature checks globally in all buffers. You can also do it
      ;; per mode with `ligature-mode'.
      (global-ligature-mode t))
    #+end_src

** Anzu mode (query & replace highlight)
#+begin_src emacs-lisp
  (use-package anzu
    :config (global-anzu-mode 1)
    (setq anzu-minimum-input-length 4)
    (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
    (global-set-key [remap query-replace] 'anzu-query-replace))
#+end_src
** Mode line
#+begin_src emacs-lisp
(use-package smart-mode-line
  :init
  (setq sml/no-confirm-load-theme t
        powerline-arrow-shape 'curve
        powerline-default-separator-dir '(right . left)
        sml/mode-width 0
        sml/name-width 20
        sml/theme 'powerline)
  :config
  (use-package smart-mode-line-powerline-theme)
  (sml/setup)
  (display-time-mode 1))

#+end_src

#+begin_src emacs-lisp :tangle no
(use-package telephone-line
  :init
  (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
      telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
      telephone-line-primary-right-separator 'telephone-line-cubed-right
      telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
  (setq telephone-line-height 24
        telephone-line-evil-use-short-tag t)
  :config
 (telephone-line-mode 1))
#+end_src
** Extra settings
#+begin_src emacs-lisp
(global-hl-line-mode 1)
(fset 'yes-or-no-p 'y-or-n-p)

(dolist (mode
       '(abbrev-mode                  ; E.g. sopl -> System.out.println
         column-number-mode           ; Show column number in mode line
         delete-selection-mode        ; Replace selected text
         dirtrack-mode                ; directory tracking in *shell*
         global-so-long-mode          ; Mitigate performance for long lines
         recentf-mode                 ; Recently opened files
         winner-mode					; “undo” and “redo” changes in WindowConfiguration
         superword-mode
         show-paren-mode))            ; Highlight matching parentheses
(funcall mode 1))
#+end_src
** COMMENT Evil mode
#+begin_src emacs-lisp
(use-package evil
  :demand t
  :bind (("<escape>" . keyboard-escape-quit))
  :init
  ;; allows for using cgn
  ;; (setq evil-search-module 'evil-search)
  (setq evil-want-keybinding nil)
  ;; no vim insert bindings
  (setq evil-undo-system 'undo-fu)
  :config
  (evil-mode 1))

(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))
#+end_src
* Enhancement
** Ediff
#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally)
#+end_src
** Uniquify
#+begin_src emacs-lisp
  ;; Every buffer should have a unique name 
  (require 'uniquify)
  (setq
   uniquify-buffer-name-style 'post-forward
   uniquify-separator ":")
#+end_src
** Hippie expand
#+begin_src emacs-lisp
  ;; hippie expand is dabbrev expand on steroids
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))
  (global-set-key (kbd "M-/") 'hippie-expand)
#+end_src
** Smartscan
=M-n= to next symbol, and =M-p= to previous symbol.
Only in elisp and c mode.
#+begin_src emacs-lisp
  (use-package smartscan
    :config
    (add-hook 'emacs-lisp-mode-hook 'smartscan-mode)
    (add-hook 'c-mode-hook 'smartscan-mode))
#+end_src
** Hungry delete
#+begin_src emacs-lisp
  (use-package hungry-delete
    :config
    (global-hungry-delete-mode))
#+end_src
** Unfill paragraph
#+begin_src emacs-lisp
  ;;; Stefan Monnier <foo at acm.org>. It is the opposite of
  ;;; fill-paragraph
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))
  ;; Handy key definition
  (define-key global-map "\M-Q" 'unfill-paragraph)
#+end_src
** Smart move to the beginning of line
#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC
** Window operation
#+BEGIN_SRC emacs-lisp
(defun my/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (if (= prefix 1)
      (switch-to-next-buffer)))
(defun my/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(global-set-key (kbd "C-x 2") 'my/vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'my/hsplit-last-buffer)

(defun sanityinc/toggle-delete-other-windows ()
  "Delete other windows in frame if any, or restore previous window config."
  (interactive)
  (if (and winner-mode
           (equal (selected-window) (next-window)))
      (winner-undo)
    (delete-other-windows)))

(global-set-key (kbd "C-x 1") 'sanityinc/toggle-delete-other-windows)

(defun split-window-horizontally-instead (prefix)
    (interactive "p")
    (delete-other-windows)
    (split-window-horizontally)
    (let ((target-window (next-window)))
                   (set-window-buffer target-window (other-buffer))))

(defun split-window-vertically-instead (prefix)
    (interactive "p")
    (delete-other-windows)
    (split-window-vertically)
    (let ((target-window (next-window)))
                   (set-window-buffer target-window (other-buffer))))

(global-set-key (kbd "C-x |") 'split-window-horizontally-instead)
(global-set-key (kbd "C-x _") 'split-window-vertically-instead)
#+END_SRC
** Smart copy/kill
#+begin_src emacs-lisp
;; Smart copy, if no region active, it simply copy the current whole line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode js-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))

(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive (if mark-active (list (region-beginning) (region-end))
                 (message "Copied line")
                 (list (line-beginning-position)
                       (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defun get-point (symbol &optional arg)
  "get the point"
  (funcall symbol arg)
  (point)
  )

(defun copy-thing (begin-of-thing end-of-thing &optional arg)
  "copy thing between beg & end into kill ring"
  (save-excursion
    (let ((beg (get-point begin-of-thing 1))
          (end (get-point end-of-thing arg)))
      (copy-region-as-kill beg end)))
  )

(defun copy-word (&optional arg)
  "Copy words at point into kill-ring"
  (interactive "P")
  (copy-thing 'subword-backward 'subword-forward arg)
  ;;(paste-to-mark arg)
  )

(global-set-key (kbd "C-c w") (quote copy-word))
#+end_src
** ibuffer-vc
#+begin_src emacs-lisp
  (use-package ibuffer-vc
    :config
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                filename-and-process))))
#+end_src
** narrow-or-widen-dwim
   #+BEGIN_SRC emacs-lisp
     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens. Otherwise, it narrows
     intelligently.  Intelligently means: region, org-src-block,
     org-subtree, or defun, whichever applies first.  Narrowing to
     org-src-block actually calls `org-edit-src-code'.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((and (boundp 'org-src-mode) org-src-mode (not p))
              (org-edit-src-exit))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode)
              (cond ((ignore-errors (org-edit-src-code)))
                    ((org-at-block-p)
                     (org-narrow-to-block))
                    (t (org-narrow-to-subtree))))
             ((derived-mode-p 'prog-mode) (narrow-to-defun))
             (t (error "Please select a region to narrow to"))))

     (global-set-key (kbd "C-x n n") 'narrow-or-widen-dwim)

   #+END_SRC
** Desktop save
#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src
** Dired
#+begin_src emacs-lisp
(setq
 dired-dwim-target t            ; if another Dired buffer is visibpple in another window, use that directory as target for Rename/Copy
 dired-recursive-copies 'always         ; "always" means no asking
 dired-recursive-deletes 'top           ; "top" means ask once for top level directory
 dired-listing-switches "-lha"          ; human-readable listing
 ls-lisp-dirs-first t
 )
(use-package dired-filetype-face)

;; auto refresh dired when file changes
(add-hook 'dired-mode-hook 'auto-revert-mode)

(with-eval-after-load 'dired  (require 'dired-filetype-face))
#+end_src
* Extensions
** ace-window
#+begin_src emacs-lisp
(use-package ace-window
  :bind ("C-x O" . ace-window))
#+end_src
** beacon-mode
Never to lose your cursor again.
#+begin_src emacs-lisp
  (use-package beacon
    :diminish beacon-mode
    :init
    (beacon-mode 1)
    (setq beacon-push-mark 35)
    (setq beacon-color "#666600"))
#+end_src
** Rainbow delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :defer t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Expand region
#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src
** nyan cat
#+begin_src emacs-lisp
  (use-package nyan-mode
    :config
    (nyan-mode 1))
#+end_src
** Key frequency
#+begin_src emacs-lisp
  (use-package keyfreq
    :init
    :config
    (setq keyfreq-excluded-commands
          '(self-insert-command
            abort-recursive-edit
            forward-char
            backward-char
            previous-line
            next-line))
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src
** Olivetti (for prose writing)
#+begin_src emacs-lisp
;; Minor mode for a nice writing environment
(use-package olivetti
  :defer t
  :bind ("C-c o" . olivetti-mode)
  :config)
#+end_src
** Focus (dim surounding texts)
#+begin_src emacs-lisp
  ;; Dim color of text in surrounding sections
  (use-package focus
    :defer t
    :bind ("C-c f" . focus-mode))
#+end_src
** Word count
#+begin_src emacs-lisp
  (use-package wc-mode)
#+end_src
** Multiple cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :bind (;("C-M" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+end_src
** Smart comment
   #+begin_src emacs-lisp
   (use-package comment-dwim-2
     :bind ("M-;" . comment-dwim-2))
   #+end_src
** Auto completion
#+begin_src emacs-lisp
;; Modular text completion framework
(use-package corfu
  :init
  (global-corfu-mode 1)
  (corfu-popupinfo-mode 1)
  :config
  (setq corfu-cycle t
        corfu-auto t
        corfu-auto-delay 0
        corfu-auto-prefix 2
        corfu-quit-at-boundary 'separator
        corfu-popupinfo-delay 0.5))
;; Emacs completion style that matches multiple regexps in any order
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic partial-completion)
        completion-category-overrides '((file (styles basic partial-completion)))
        orderless-component-separator "[ |]"))
#+end_src

* Program
** cc-mode
#+begin_src emacs-lisp
  (defun linux-c-mode()
    (define-key c-mode-map [return] 'newline-and-indent)
    (interactive)
    (c-set-style "K&R")
    (c-toggle-auto-state)
    (setq c-basic-offset 8)
    (setq indent-tabs-mode nil)
    (c-toggle-hungry-state)
    (imenu-add-menubar-index)
    (which-function-mode)
    (c-toggle-auto-newline 1)
    (c-set-offset 'inextern-lang 0)
    )

  (defun linux-cpp-mode()
    (define-key c++-mode-map [return] 'newline-and-indent)
    (define-key c++-mode-map [(control c) (c)] 'compile)
    (interactive)
    (c-set-style "K&R")
    (c-toggle-auto-state)
    (c-toggle-hungry-state)

    (setq c++-tab-always-indent t)
        (setq c-basic-offset 3)
        (setq indent-tabs-mode nil)
        (imenu-add-menubar-index)
        (which-function-mode)
        (c-set-offset 'inextern-lang 0))

  (add-hook 'c-mode-hook 'linux-c-mode)
  (add-hook 'c++-mode-hook 'linux-cpp-mode)

  (use-package color-identifiers-mode
    :config
    (add-hook 'c-mode-hook 'color-identifiers-mode)
    (add-hook 'c++-mode-hook 'color-identifiers-mode))
#+end_src
** Makefile
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("[Mm]akefile*" . makefile-gmake-mode))
(defun prelude-makefile-mode-defaults ()
  (setq indent-tabs-mode t ))

(setq prelude-makefile-mode-hook 'prelude-makefile-mode-defaults)

(add-hook 'makefile-mode-hook (lambda ()
                                (run-hooks 'prelude-makefile-mode-hook)))
#+END_SRC

** Markdown
#+begin_src emacs-lisp
;; Emacs Major mode for Markdown-formatted files
(use-package markdown-mode
  :defer t)
#+end_src
** dtrt-indent
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent)
(add-hook 'c-mode-common-hook
          (lambda()
            (require 'dtrt-indent)
            ;; (setq dtrt-indent-verbosity 0)
            (dtrt-indent-mode t)))
#+END_SRC
** Aggressive indent
   #+begin_src emacs-lisp
   (use-package aggressive-indent
     :config
     (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
     (add-hook 'css-mode-hook #'aggressive-indent-mode))
   #+end_src
** Fly spell
#+begin_src emacs-lisp
(defun cycle-languages ()
  "Changes the ispell dictionary to the first element in
ISPELL-LANGUAGES, and returns an interactive function that cycles
the languages in ISPELL-LANGUAGES when invoked."
  (let ((ispell-languages (list "american" "norsk")))
    (lambda ()
      (interactive)
      ;; Rotates the languages cycle and changes the ispell dictionary.
      (let ((rotated (nconc (cdr ispell-languages) (list (car ispell-languages)))))
        (ispell-change-dictionary (car (setq ispell-languages rotated)))))))

(use-package flyspell
  :defer t
  :if (executable-find "aspell")
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode)
         (flyspell-mode . (lambda ()
                            (local-set-key
                             (kbd "C-c l")
                             (cycle-languages)))))
  :config
  (ispell-change-dictionary "american" t))
#+end_src
** Magit
#+begin_src emacs-lisp
;; A Git porcelain inside Emacs.
(use-package magit
  :bind ("C-x g" . magit-status))

(use-package git-timemachine)
#+end_src
** Git gutter
   #+begin_src emacs-lisp
   (use-package git-gutter
     :config
     (setq git-gutter:update-interval 0.02)
     (global-git-gutter-mode +1))

   (use-package git-gutter-fringe
     :config
     (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
     (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
     (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
   #+end_src
** Helm
*** Basic
***  setting
#+begin_src emacs-lisp
(use-package helm
  :ensure t
  :config
  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t)

  :bind (("C-c h" . helm-command-prefix)
         ("M-x" . helm-M-x)
         ("C-x y" . helm-show-kill-ring)
         ("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("M-i" . helm-occur)
         :map helm-command-map
         ("C-i" . helm-execute-persistent-action)
         ("C-i" . helm-select-action)
         ("<tab>" . helm-execute-persistent-action))
  )

(global-unset-key (kbd "C-x c"))
#+end_src
*** Helm gtags
#+begin_src emacs-lisp
(use-package helm-gtags
  :after helm                      
  :config
  (setq helm-gtags-auto-update t)
  (setq helm-gtags-update-interval-second 60)
  :bind (:map helm-gtags-mode-map
              ("M-t" . helm-gtags-find-tag)
              ("M-r" . helm-gtags-find-rtag)
              ("M-s" . helm-gtags-find-symbol)
              ("M-g M-p" . helm-gtags-parse-file)
              ("C-c <" . helm-gtags-previous-history)
              ("C-c >" . helm-gtags-next-history)
              ("M-," . helm-gtags-pop-stack))
  :hook ((c-mode-hook . helm-gtags-mode)
         (c++-mode-hook . helm-gtags-mode)
         (asm-mode-hook . helm-gtags-mode)))
#+end_src
*** Helm projectile
#+begin_src emacs-lisp
(use-package helm-projectile
  :diminish t
  :after helm
  :bind (("C-c p f" . helm-projectile-find-file-dwim)
         ("C-c p p" . helm-projectile-switch-project)
         ("C-c p b" . helm-projectile-switch-to-buffer)
         ("C-c p g" . helm-projectile-grep)))

(projectile-global-mode)
(setq projectile-completion-system 'helm)
(helm-projectile-on)

(setq projectile-enable-caching t)
#+end_src
*** Helm exwm
#+begin_src emacs-lisp
(use-package helm-exwm
  :ensure t
  :bind ("C-x B" . helm-exwm)
  :config
  (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
  (setq helm-exwm-source (helm-exwm-build-source))
  (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                    helm-exwm-source
                                    helm-source-recentf)))
#+end_src
*** helm-ag
    Rely on =ripgrep=, install it firstly.
 #+begin_src emacs-lisp
 (use-package helm-ag
   :init
   (setq helm-ag-base-command "rg"
         helm-ag-command-option "--no-heading"
         helm-ag-insert-at-point 'symbol)
   :bind
   ("C-c h g" . helm-do-ag)
 )
 #+end_src

** Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :diminish t
  :init
  (setq helm-yas-space-match-any-greedy t)
  (setq yas-prompt-functions '(yas-dropdown-prompt
                               yas-ido-prompt
                               yas-completing-prompt))
  :config
  (use-package helm-c-yasnippet)
  (yas-global-mode 1)
  (add-hook 'term-mode-hook (lambda()
                              (yas-minor-mode -1))))
#+end_src

** Compilation
#+begin_src emacs-lisp
(defun prelude-colorize-compilation-buffer ()
  "Colorize a compilation mode buffer."
  (interactive)
  ;; we don't want to mess with child modes such as grep-mode, ack, ag, etc
  (when (eq major-mode 'compilation-mode)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max)))))
(setq compilation-ask-about-save nil          ; Just save before compiling
      compilation-always-kill t               ; Just kill old compile processes before starting the new one
      compilation-scroll-output 'first-error) ; Automatically scroll to first
(use-package cd-compile
  :bind ("<f5>" . cd-compile))
#+end_src

** Smartparens
#+begin_src emacs-lisp
(use-package smartparens-mode
  :ensure smartparens  ;; install the package
  :hook (prog-mode text-mode markdown-mode) ;; add `smartparens-mode` to these hooks
  :config
  ;; load default config
  (require 'smartparens-config))
#+end_src
** TODO COMMENT Treesitter
#+begin_src emacs-lisp
(use-package treesit
  :defer t
  :hook ((bash-ts-mode c-ts-mode c++-ts-mode
          html-ts-mode js-ts-mode typescript-ts-mode
          json-ts-mode rust-ts-mode tsx-ts-mode python-ts-mode
          css-ts-mode yaml-ts-mode) . lsp-deferred)
  :init
  (setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (c "https://github.com/tree-sitter/tree-sitter-c")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (common-lisp "https://github.com/theHamsta/tree-sitter-commonlisp")
     (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (csharp "https://github.com/tree-sitter/tree-sitter-c-sharp")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (go-mod "https://github.com/camdencheek/tree-sitter-go-mod")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (js . ("https://github.com/tree-sitter/tree-sitter-javascript" "master" "src"))
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (lua "https://github.com/Azganoth/tree-sitter-lua")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (r "https://github.com/r-lib/tree-sitter-r")
     (rust "https://github.com/tree-sitter/tree-sitter-rust")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
     (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src"))
     (yaml "https://github.com/ikatyang/tree-sitter-yaml"))))
#+end_src
** TODO COMMENT Editor config
#+begin_src emacs-lisp
  ;; EditorConfig Emacs Plugin
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src
** TODO COMMENT Eglot
* Org mode
** Basics
#+begin_src emacs-lisp
(use-package org
  :defer t
  :bind (("C-c c" . org-capture)
         :map org-mode-map
         ("M-;" . org-comment-dwim))
  :config
  (setq org-adapt-indentation t
        org-hide-leading-stars t
        org-hide-emphasis-markers t
        org-pretty-entities t
        org-src-fontify-natively t
        org-edit-src-content-indentation 0
        org-ellipsis "⤵")
  (add-hook 'org-mode-hook (lambda () (org-indent-mode t))))
#+end_src
** org-babel
#+begin_src emacs-lisp
(use-package gnuplot)
(use-package plantuml-mode)
;; active Babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (dot . t)
   (ditaa . t)
   (python . t)
   (gnuplot . t)
   (plantuml . t)
   (emacs-lisp . t)
   ))
;; Install plantuml.jar by: sudo apt install plantuml
(setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
(setq puml-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+end_src
** Plantuml
#+begin_src emacs-lisp
(use-package plantuml-mode
  :defer t
  :mode ("\\.\\(pum\\|puml\\)\\'" . plantuml-mode)
  :after ob
  :init
  (add-to-list 'org-babel-load-languages '(plantuml . t))
  :config
  (setq plantuml-default-exec-mode 'jar
        plantuml-jar-path "~/.local/bin/plantuml.jar"
        org-plantuml-jar-path "~/.local/bin/plantuml.jar"))
#+end_src
** Graphviz(dot)
#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :defer t
  :after org
  :mode (("\\.diag\\'"      . graphviz-dot-mode)
         ("\\.blockdiag\\'" . graphviz-dot-mode)
         ("\\.nwdiag\\'"    . graphviz-dot-mode)
         ("\\.rackdiag\\'"  . graphviz-dot-mode)
         ("\\.dot\\'"       . graphviz-dot-mode)
         ("\\.gv\\'"        . graphviz-dot-mode))
  :init
  (setq graphviz-dot-indent-width tab-width)
  (with-eval-after-load 'org
      (defalias 'org-babel-execute:graphviz-dot #'org-babel-execute:dot)
      (add-to-list 'org-babel-load-languages '(dot . t))
      (require 'ob-dot)
      (setq org-src-lang-modes
            (append '(("dot" . graphviz-dot))
                    (delete '("dot" . fundamental) org-src-lang-modes)))))

#+end_src
** COMMENT Org auto tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Org modern
#+begin_src emacs-lisp
;; Modern looks for Org
(use-package org-modern
  :after org
  :hook
  (org-mode . org-modern-mode)
  :config
  (setq org-modern-block-fringe nil))
#+end_src
** org-journal
#+begin_src emacs-lisp
(use-package org-journal
  :init
  (setq org-journal-dir "~/org/journal/"
        org-journal-date-format "%A, %d %B %Y"
        org-journal-file-type 'weekly)
  :bind
  ("<f6>" . org-journal-new-entry))
#+end_src
** org-ai
#+begin_src emacs-lisp
(use-package org-ai
  :ensure t
  :commands (org-ai-mode
             org-ai-global-mode)
  :init
  (add-hook 'org-mode-hook #'org-ai-mode) ; enable org-ai in org-mode
  (org-ai-global-mode) ; installs global keybindings on C-c M-a
  :config
  (setq org-ai-default-chat-model "gpt-4") ; if you are on the gpt-4 beta:
  (org-ai-install-yasnippets)) ; if you are using yasnippet and want `ai` snippets
#+end_src

** org-download
#+begin_src emacs-lisp
(use-package org-download
    :after org
    :bind
    (:map org-mode-map
    (("s-Y" . org-download-screenshot)
        ("s-y" . org-download-yank)))
    :config
    (if (memq window-system '(mac ns))
        (setq org-download-screenshot-method "screencapture -i %s")
        (setq org-download-screenshot-method "flameshot gui --raw > %s")
        )
    (defun my-org-download-method (link)
        "This is a helper function for org-download.
    It creates a folder in the root directory (~/.org/img/) named after the
    org filename (sans extension) and puts all images from that file in there.
    Inspired by https://github.com/daviderestivo/emacs-config/blob/6086a7013020e19c0bc532770e9533b4fc549438/init.el#L701"
        (let ((filename
            (file-name-nondirectory
                (car (url-path-and-query
                    (url-generic-parse-url link)))))
            ;; Create folder name with current buffer name, and place in root dir
            (dirname (concat "./images/"
                            (replace-regexp-in-string " " "_" (downcase (file-name-base buffer-file-name))))))

        ;; Add timestamp to filename
        (setq filename-with-timestamp (format "%s%s.%s"
                                                (file-name-sans-extension filename)
                                                (format-time-string org-download-timestamp)
                                                (file-name-extension filename)))
        ;; Create folder if necessary
        (unless (file-exists-p dirname)
            (make-directory dirname t))
        (expand-file-name filename-with-timestamp dirname)))
    (setq org-download-method 'my-org-download-method))
#+end_src

** org-capture
#+begin_src emacs-lisp
;; Org-capture templates
(setq org-my-anki-file "~/org/capture/anki.org")

(setq org-capture-templates
      '(
        ("a" "Anki basic"
         entry
         (file+headline org-my-anki-file "Dispatch Shelf")
         "* %<%H:%M>   %^g\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Basic\n:ANKI_DECK: Mega\n:END:\n** Front\n%?\n** Back\n%x\n")
        ("A" "Anki cloze"
         entry
         (file+headline org-my-anki-file "Dispatch Shelf")
         "* %<%H:%M>   %^g\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Cloze\n:ANKI_DECK: Mega\n:END:\n** Text\n%x\n** Extra\n")))
#+end_src
** org-roam
#+begin_src emacs-lisp
;; Copy from https://ag91.github.io/blog/2022/02/05/an-helm-source-for-org-roam-v2/
(defun helm-org-roam (&optional input candidates)
  (interactive)
  (require 'org-roam)
  (helm
   :input input
   :sources (list
             (helm-build-sync-source "Roam: "
               :must-match nil
               :fuzzy-match t
               :candidates (or candidates (org-roam--get-titles))
               :action
               '(("Find File" . (lambda (x)
                                  (--> x
                                       org-roam-node-from-title-or-alias
                                       (org-roam-node-visit it t))))
                 ("Insert link" . (lambda (x)
                                    (--> x
                                         org-roam-node-from-title-or-alias
                                         (insert
                                          (format
                                           "[[id:%s][%s]]"
                                           (org-roam-node-id it)
                                           (org-roam-node-title it))))))
                 ("Follow backlinks" . (lambda (x)
                                         (let ((candidates
                                                (--> x
                                                     org-roam-node-from-title-or-alias
                                                     org-roam-backlinks-get
                                                     (--map
                                                      (org-roam-node-title
                                                       (org-roam-backlink-source-node it))
                                                      it))))
                                           (helm-org-roam nil (or candidates (list x))))))))
             (helm-build-dummy-source
                 "Create note"
               :action '(("Capture note" . (lambda (candidate)
                                             (org-roam-capture-
                                              :node (org-roam-node-create :title candidate)
                                              :props '(:finalize find-file)))))))))

(defun org-roam-tag-add-non-interactive (tags)
  "Add TAGS to the node at point."
  (let ((node (org-roam-node-at-point 'assert)))
    (goto-char (org-roam-node-point node))
    (if (= (org-outline-level) 0)
        (let ((current-tags (split-string (or (cadr (assoc "FILETAGS"
                                                           (org-collect-keywords '("filetags"))))
                                              "")
                                          ":" 'omit-nulls)))
          (org-roam-set-keyword "filetags" (org-make-tag-string (seq-uniq (append tags current-tags)))))
      (org-set-tags (seq-uniq (append tags (org-get-tags)))))))

(defun helm-org-roam-tag (&optional input candidates)
  (interactive)
  (require 'org-roam)
  (helm
   :input input
   :sources (list
             (helm-build-sync-source "Roam: "
               :must-match nil
               :fuzzy-match t
               :candidates (or candidates (org-roam-tag-completions))
               :action
               '(("Add tag" . (lambda (candidate)
                                (org-roam-tag-add-non-interactive (list candidate))
                                ))))
             (helm-build-dummy-source
                 "Create tag"
               :action '(("New tag" . (lambda (candidate)
                                        (org-roam-tag-add-non-interactive (list candidate))
                                        )))))))

(use-package org-roam
  :ensure t
  :custom
  (org-roam-directory (file-truename "~/org/roam/"))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ("C-c n t" . helm-org-roam-tag)
         ("C-c n T" . org-roam-tag-remove)
         ("C-c n o" . helm-org-roam)
         ;; Dailies
         ("C-c n j" . org-roam-dailies-capture-today))
  :config
  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-mode)
  ;; If using org-roam-protocol
  (require 'org-roam-protocol))
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :bind ("<f6>" . deft)
  :config
  (setq deft-directory org-roam-directory
        deft-recursive t
        deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
        deft-extensions '("md" "org")
        deft-use-filename-as-title t))
#+end_src
*** org-roam-ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src
** Latex
#+begin_src emacs-lisp
(require 'ox-latex)
(require 'ox-beamer)
(setq org-latex-images-centered 't)

(setq org-latex-coding-system 'utf-8)

(setf org-latex-default-packages-alist
      (remove '("AUTO" "inputenc" t) org-latex-default-packages-alist))
(setf org-latex-default-packages-alist
      (remove '("T1" "fontenc" t) org-latex-default-packages-alist))

(setq org-latex-pdf-process '("xelatex -8bit -shell-escape  %f"
                              "xelatex -8bit -shell-escape  %f"))
(setq org-latex-packages-alist
      '("
        \\hypersetup{ colorlinks,% 
                linkcolor=blue,% 
                citecolor=black,%
                urlcolor=black,%
                filecolor=black
               }

        \\usepackage{array}
        \\usepackage{xcolor}
        \\definecolor{bg}{rgb}{0.95,0.95,0.95}"))

(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)
(setq org-latex-minted-options
      '(
        ("bgcolor" "bg")
        ("frame" "lines")
        ("linenos" "")
        ("fontsize" "\\scriptsize")
        ))

(add-to-list 'org-latex-classes
             '("article-cn"
              "\\documentclass[11pt]{article}
                [DEFAULT-PACKAGES]
                [PACKAGES]
                \\usepackage{fontspec}

                \\XeTeXlinebreaklocale ``zh''
                \\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
                \\newcommand\\fontnamehei{WenQuanYi Zen Hei}
                \\newcommand\\fontnamesong{AR PL UMing CN}
                \\newcommand\\fontnamekai{AR PL KaitiM GB}
                \\newcommand\\fontnamemono{FreeMono}
                \\newcommand\\fontnameroman{FreeSans}
                \\setmainfont[BoldFont=\\fontnamehei]{\\fontnamesong}
                \\setsansfont[BoldFont=\\fontnamehei]{\\fontnamekai}
                \\setmonofont{\\fontnamemono}
                \\setromanfont[BoldFont=\\fontnamehei]{\\fontnamesong}
                \\makeatletter
                \\def\\verbatim@font{\\rmfamily\\small} %verbatim中使用roman字体族
                \\makeatother"

              ("\\section{%s}" . "\\section*{%s}")
              ("\\subsection{%s}" . "\\subsection*{%s}")
              ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
              ("\\paragraph{%s}" . "\\paragraph*{%s}")
              ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
             '("article-img"
              "\\documentclass[11pt]{article}
                [DEFAULT-PACKAGES]
                [PACKAGES]
                \\usepackage{geometry}
                \\geometry{left=1.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm}"
              ("\\section{%s}" . "\\section*{%s}")
              ("\\subsection{%s}" . "\\subsection*{%s}")
              ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
              ("\\paragraph{%s}" . "\\paragraph*{%s}")
              ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src
* Shells
** Eshell
#+begin_src emacs-lisp
(setq eshell-scroll-to-bottom-on-input t) ; press any key to jump back to the prompt:
(setq eshell-prefer-lisp-functions nil)
#+end_src
* Exwm
#+begin_src emacs-lisp
(defun exwm/run-in-background (command &optional once)
  (let ((command-parts (split-string command " +")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

(use-package exwm
  :if (seq-contains-p command-line-args "--with-exwm")
  :config
  (set-frame-parameter (selected-frame) 'alpha-background 0.7)
  (require 'exwm-randr)
  ;; (exwm/run-in-background "feh --bg-scale \"${cat $HOME/Pictures/wall-paper.jpg}\"")
  (start-process-shell-command
   "xrandr" nil "xrandr --output eDP --mode 1920x1200")

  ;; Emacs server is not required to run EXWM but it has some interesting uses
  (server-start)

  (require 'exwm-config)
  ;; Set the initial workspace number.
  (unless (get 'exwm-workspace-number 'saved-value)
    (setq exwm-workspace-number 2))
  ;; Make class name the buffer name
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
  ;; Global keybindings.
  (unless (get 'exwm-input-global-keys 'saved-value)
    (setq exwm-input-global-keys
          `(
            ;; 's-r': Reset (to line-mode).
            ([?\s-R] . exwm-restart)
            ;; 's-w': Switch workspace.
            ([?\s-w] . exwm-workspace-switch)
            ;; 's-1': Switch workspace.
            ([?\s-1] . (exwm-workspace-switch 0))
            ;; 's-d': Launch application.
            ([?\s-d] . dmenu))))

            ;; ;; 's-N': Switch to certain workspace.
            ;; ,@(mapcar (lambda (i)
            ;;             `(,(kbd (format "s-%d" i)) .
            ;;               (lambda ()
            ;;                 (interactive)
            ;;                 (exwm-workspace-switch-create ,i))))
            ;;           (number-sequence 0 9))))
  ;; Line-editing shortcuts
  (unless (get 'exwm-input-simulation-keys 'saved-value)
    (setq exwm-input-simulation-keys
          '(([?\C-b] . [left])
            ([?\C-f] . [right])
            ([?\C-p] . [up])
            ([?\C-n] . [down])
            ([?\C-a] . [home])
            ([?\C-e] . [end])
            ([?\M-v] . [prior])
            ([?\C-v] . [next])
            ([?\C-d] . [delete])
            ([?\C-k] . [S-end delete]))))
  ;; Enable EXWM
  (exwm-enable)
  (exwm-randr-enable)
  (exwm-config-ido)
  (exwm-config-misc))
#+end_src
* Other tools
** Dictionary
#+begin_src emacs-lisp
;; display the definition of word at point
(use-package sdcv
  :defer t
  :bind ("C-c d" . sdcv-search-input))
#+end_src
** Which key (show available keybindings)
#+begin_src emacs-lisp
;; Display available keybindings in popup
(use-package which-key
  :config
  (which-key-mode 1))
#+end_src
** Pdf tools
   #+begin_src emacs-lisp
   (use-package pdf-tools
     :config
     (pdf-tools-install))
   (use-package org-noter)
   #+end_src
