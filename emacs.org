#+OPTIONS: toc:4 h:4
#+TITLE: Emacs init configuration
* Package management
#+begin_src emacs-lisp
(require 'use-package)
(setq use-package-always-ensure t)

(setq package-archives
    '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
      ("MELPA Stable" . "https://stable.melpa.org/packages/")
      ("MELPA"        . "https://melpa.org/packages/"))
    package-archive-priorities
    '(("GNU ELPA"     . 10)
      ("MELPA"        . 5)
      ("MELPA Stable" . 0)))
#+end_src
** Straight
#+begin_src emacs-lisp :lexical no
;; bootstrap straight
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; use use-package
(straight-use-package 'use-package)
;; automatically ensure every package exists (like :ensure or :straight)
;; (setq straight-use-package-by-default t)
#+end_src
** Paradox
#+begin_src emacs-lisp
(use-package async
             :ensure t)
(use-package paradox
             :ensure t
             :config
             (setq paradox-execute-asynchronously t
                   ;; Avoid being ask for the token
                   paradox-github-token 0))

#+end_src
** Auto compile
#+begin_src emacs-lisp
(setq load-prefer-newer t)
(use-package auto-compile
 :ensure t
 :config
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1))
#+end_src
* General
** Basics
#+begin_src emacs-lisp
(setq-default tab-width 4                       ; Smaller tabs
              ;; fill-column 79                    ; Maximum line width
              ;; auto-fill-function 'do-auto-fill  ; Auto-fill-mode everywhere
              truncate-lines t                  ; Don't fold lines
              indent-tabs-mode nil              ; Use spaces instead of tabs
              split-width-threshold 80           ; Split Horizontally by default
              split-height-threshold 80        ; Split Horizontally by default
              frame-resize-pixelwise t          ; Fine-grained frame resize
              frame-title-format "%f %4 %b %Z %* %10 %I"
              x-select-enable-clipboard t
              x-select-enable-primary t)
(setq auto-revert-interval 1            ; Refresh buffers fast
      default-input-method "TeX"        ; Use TeX when toggling input method
      echo-keystrokes 0.1               ; Show keystrokes asap
      enable-recursive-minibuffers t    ; Allow recursive minibuffers
      frame-inhibit-implied-resize 1    ; Don't resize frame implicitly
      inhibit-startup-screen t          ; No splash screen please
      initial-scratch-message nil       ; Clean scratch buffer
      recentf-max-saved-items 10000     ; Show more recent files
      ring-bell-function 'ignore        ; Quiet
      scroll-margin 1                   ; Space between cursor and top/bottom
      sentence-end-double-space nil     ; No double space
      local-elisp-directory             ; Customization of local elisp codes
      (concat user-emacs-directory "extension/")
      custom-file                       ; Customizations in a separate file
      (concat user-emacs-directory "custom.el"))

;; Vertical Scroll
(setq scroll-step 1
      scroll-margin 5
      scroll-conservatively 101
      scroll-up-aggressively 0.01
      scroll-down-aggressively 0.01
      auto-window-vscroll nil
      fast-but-imprecise-scrolling nil
      mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      ;; Horizontal Scroll
      hscroll-step 1
      hscroll-margin 1)

(global-set-key (kbd "C-w") 'backward-kill-word)
(global-set-key (kbd "C-x C-k") 'kill-region)
(global-set-key (kbd "C-x C-b") 'ibuffer-list-buffers)

(global-set-key (kbd "<f8>") 'eshell)
#+end_src

** Auto save
The aim is save =C-x C-s=, the most frequently used key.
An alternative: https://github.com/manateelazycat/auto-save/tree/master
#+begin_src emacs-lisp
(use-package real-auto-save
  :config
  (setq real-auto-save-interval 2)
  (add-hook 'org-mode-hook 'real-auto-save-mode)
  (add-hook 'prog-mode-hook 'real-auto-save-mode)
  (add-hook 'text-mode-hook 'real-auto-save-mode)
  (add-hook 'conf-mode-hook 'real-auto-save-mode)
  )
#+end_src
** Desktop save
#+begin_src emacs-lisp
  (desktop-save-mode 1)
#+end_src
** GUI
#+begin_src emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
(when (functionp 'column-number-mode)
  (column-number-mode 1))
(when (functionp 'line-number-mode)
    (line-number-mode 1))
#+end_src
** Prettify symbols
#+begin_src emacs-lisp
(when (boundp 'global-prettify-symbols-mode)
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("lambda" . ?λ) prettify-symbols-alist)))
  (add-hook 'clojure-mode-hook
            (lambda ()
              (push '("fn" . ?ƒ) prettify-symbols-alist)))
  (global-prettify-symbols-mode +1))
#+end_src
** Color theme
#+begin_src emacs-lisp
(use-package zenburn-theme
  :init
  :config
  (load-theme 'zenburn t))

;; (use-package nord-theme)
;; (load-theme 'nord t)

;; (load-theme 'solarized-dark t)


#+end_src
** OS related && fonts
#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  (set-face-attribute 'default nil)
  (set-face-attribute 'default nil :height 150))

(when (eq system-type 'gnu/linux)
  (if window-system
      ;; Chinese Font
      (dolist (charset '(kana han symbol cjk-misc bopomofo))
        (set-frame-font "Inconsolata 18")
        ;; (set-frame-font "CascadiaCode 16")
        ;; (set-frame-font "Firacode 15")
        (set-fontset-font (frame-parameter nil 'font)
                          charset (font-spec :family "WenQuanYi Micro Hei Mono"
                                             :size 16))
        ;; Default Browser
        (setq browse-url-browser-function 'browse-url-generic
              browse-url-generic-program "firefox"
              browse-url-new-window-flag t)
        )))
#+end_src
*** COMMENT Ligature
    #+begin_src emacs-lisp
    (use-package ligature
      :config
      ;; Enable the "www" ligature in every possible major mode
      (ligature-set-ligatures 't '("www"))
      ;; Enable traditional ligature support in eww-mode, if the
      ;; `variable-pitch' face supports it
      (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
      ;; Enable all Cascadia and Fira Code ligatures in programming modes
      (ligature-set-ligatures 'prog-mode
                            '(;; == === ==== => =| =>>=>=|=>==>> ==< =/=//=// =~
                              ;; =:= =!=
                              ("=" (rx (+ (or ">" "<" "|" "/" "~" ":" "!" "="))))
                              ;; ;; ;;;
                              (";" (rx (+ ";")))
                              ;; && &&&
                              ("&" (rx (+ "&")))
                              ;; !! !!! !. !: !!. != !== !~
                              ("!" (rx (+ (or "=" "!" "\." ":" "~"))))
                              ;; ?? ??? ?:  ?=  ?.
                              ("?" (rx (or ":" "=" "\." (+ "?"))))
                              ;; %% %%%
                              ("%" (rx (+ "%")))
                              ;; |> ||> |||> ||||> |] |} || ||| |-> ||-||
                              ;; |->>-||-<<-| |- |== ||=||
                              ;; |==>>==<<==<=>==//==/=!==:===>
                              ("|" (rx (+ (or ">" "<" "|" "/" ":" "!" "}" "\]"
                                              "-" "=" ))))
                              ;; \\ \\\ \/
                              ("\\" (rx (or "/" (+ "\\"))))
                              ;; ++ +++ ++++ +>
                              ("+" (rx (or ">" (+ "+"))))
                              ;; :: ::: :::: :> :< := :// ::=
                              (":" (rx (or ">" "<" "=" "//" ":=" (+ ":"))))
                              ;; // /// //// /\ /* /> /===:===!=//===>>==>==/
                              ("/" (rx (+ (or ">"  "<" "|" "/" "\\" "\*" ":" "!"
                                              "="))))
                              ;; .. ... .... .= .- .? ..= ..<
                              ("\." (rx (or "=" "-" "\?" "\.=" "\.<" (+ "\."))))
                              ;; -- --- ---- -~ -> ->> -| -|->-->>->--<<-|
                              ("-" (rx (+ (or ">" "<" "|" "~" "-"))))
                              ;; *> */ *)  ** *** ****
                              ("*" (rx (or ">" "/" ")" (+ "*"))))
                              ;; www wwww
                              ("w" (rx (+ "w")))
                              ;; <> <!-- <|> <: <~ <~> <~~ <+ <* <$ </  <+> <*>
                              ;; <$> </> <|  <||  <||| <|||| <- <-| <-<<-|-> <->>
                              ;; <<-> <= <=> <<==<<==>=|=>==/==//=!==:=>
                              ;; << <<< <<<<
                              ("<" (rx (+ (or "\+" "\*" "\$" "<" ">" ":" "~"  "!"
                                              "-"  "/" "|" "="))))
                              ;; >: >- >>- >--|-> >>-|-> >= >== >>== >=|=:=>>
                              ;; >> >>> >>>>
                              (">" (rx (+ (or ">" "<" "|" "/" ":" "=" "-"))))
                              ;; #: #= #! #( #? #[ #{ #_ #_( ## ### #####
                              ("#" (rx (or ":" "=" "!" "(" "\?" "\[" "{" "_(" "_"
                                           (+ "#"))))
                              ;; ~~ ~~~ ~=  ~-  ~@ ~> ~~>
                              ("~" (rx (or ">" "=" "-" "@" "~>" (+ "~"))))
                              ;; __ ___ ____ _|_ __|____|_
                              ("_" (rx (+ (or "_" "|"))))
                              ;; Fira code: 0xFF 0x12
                              ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))
                              ;; Fira code:
                              "Fl"  "Tl"  "fi"  "fj"  "fl"  "ft"
                              ;; The few not covered by the regexps.
                              "{|"  "[|"  "]#"  "(*"  "}#"  "$>"  "^="))
      ;; Enables ligature checks globally in all buffers. You can also do it
      ;; per mode with `ligature-mode'.
      (global-ligature-mode t))
    #+end_src

** Anzu mode (query & replace highlight)
#+begin_src emacs-lisp
  (use-package anzu
    :config (global-anzu-mode 1)
    (setq anzu-minimum-input-length 4)
    (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
    (global-set-key [remap query-replace] 'anzu-query-replace))
#+end_src
** Mode line & awesome-tray
#+begin_src emacs-lisp :lexical no
(defun find-color (name)
  "Find the color associated with a name in a given color list."
  (cdr (assoc name zenburn-default-colors-alist)))

(use-package awesome-tray
  :straight (:host github :repo "manateelazycat/awesome-tray"
                   :branch "master")
  :after zenburn-theme
  :init
  (setq awesome-tray-mode-line-active-color "DarkGray")
  (setq awesome-tray-file-path-show-filename t)
  :config
  (awesome-tray-mode 1)
  (eval-after-load "zenburn-theme"
    '(progn
       ;; change mode-line color
       (set-face-attribute 'awesome-tray-green-face  nil  :foreground (find-color "zenburn-green"))
       (set-face-attribute 'awesome-tray-green-path-face  nil  :foreground (find-color "zenburn-green+4"))
       (set-face-attribute 'awesome-tray-orange-face  nil  :foreground (find-color "zenburn-orange"))
       (set-face-attribute 'awesome-tray-cyan-face  nil  :foreground (find-color "zenburn-cyan"))
       (set-face-attribute 'awesome-tray-yellow-face  nil  :foreground (find-color "zenburn-yellow"))
       (set-face-attribute 'awesome-tray-pink-face  nil  :foreground (find-color "zenburn-magenta"))
       (set-face-attribute 'awesome-tray-red-face  nil  :foreground (find-color "zenburn-red"))
       )))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package smart-mode-line
  :init
  (setq sml/no-confirm-load-theme t
        powerline-arrow-shape 'curve
        powerline-default-separator-dir '(right . left)
        sml/mode-width 0
        sml/name-width 20
        sml/theme 'powerline)
  :config
  (use-package smart-mode-line-powerline-theme)
  (sml/setup)
  (display-time-mode 1))

#+end_src

#+begin_src emacs-lisp :tangle no
(use-package telephone-line
  :init
  (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
      telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
      telephone-line-primary-right-separator 'telephone-line-cubed-right
      telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
  (setq telephone-line-height 24
        telephone-line-evil-use-short-tag t)
  :config
 (telephone-line-mode 1))
#+end_src
** Open newline & move text
#+begin_src emacs-lisp :lexical no
(use-package move-text
  :straight (:host github :repo "manateelazycat/move-text"))

(defun scroll-up-one-line()
  "Scroll up one line."
  (interactive)
  (scroll-up 1))

(defun scroll-down-one-line()
  "Scroll down one line."
  (interactive)
  (scroll-down 1))
(global-set-key (kbd "s-p") 'scroll-up-one-line)
(global-set-key (kbd "s-n") 'scroll-down-one-line)
(global-set-key (kbd "s-P") 'move-text-up)
(global-set-key (kbd "s-N") 'move-text-down)

(defun open-newline-below (arg)
  "Move to the next line (like vi) and then opens a line."
  (interactive "p")
  (end-of-line)
  (open-line arg)
  (call-interactively 'next-line arg)
  (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
      (indent-according-to-mode)
    (beginning-of-line)))
(defun open-newline-above (arg)
  "Move to the previous line (like vi) and then opens a line."
  (interactive "p")
  (beginning-of-line)
  (open-line arg)
  (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
      (indent-according-to-mode)
    (beginning-of-line)))

(global-set-key (kbd "C-l") 'open-newline-below)
(global-set-key (kbd "C-o") 'open-newline-above)
(global-set-key (kbd "M-,") 'goto-last-change)
#+end_src
** Extra settings
#+begin_src emacs-lisp
(global-hl-line-mode 1)
(fset 'yes-or-no-p 'y-or-n-p)

(dolist (mode
         '(abbrev-mode                  ; E.g. sopl -> System.out.println
           column-number-mode           ; Show column number in mode line
           delete-selection-mode        ; Replace selected text
           dirtrack-mode                ; directory tracking in *shell*
           global-so-long-mode          ; Mitigate performance for long lines
           recentf-mode                 ; Recently opened files
           winner-mode					; “undo” and “redo” changes in WindowConfiguration
           global-superword-mode        ;
           global-auto-revert-mode
           save-place-mode
           show-paren-mode))            ; Highlight matching parentheses
  (funcall mode 1))

(use-package goto-line-preview
  :config
  (global-set-key [remap goto-line] 'goto-line-preview))

(use-package browse-kill-ring
  :bind (("M-y" . browse-kill-ring)))
;; (use-package vundo)

(use-package winpoint
  ;; Keep cursor while opening two buffers for a file.
  ;; https://raw.githubusercontent.com/manateelazycat/lazycat-emacs/47ed27a317c9d81b9ae4727a62c43bccc585b8b1/site-lisp/extensions/lazycat/winpoint.el
  :if (file-exists-p
       (expand-file-name "winpoint.el" local-elisp-directory))
  :load-path local-elisp-directory
  :config
  (add-hook 'prog-mode-hook 'winpoint-mode)
  (add-hook 'org-mode-hook 'winpoint-mode))

(use-package cursor-chg
  ;; make cursor terser
  ;; https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/cursor-chg.el
  :if (file-exists-p
       (expand-file-name "cursor-chg.el" local-elisp-directory))
  :load-path local-elisp-directory
  :config
  (setq curchg-default-cursor-color "White")
  (change-cursor-mode 1)
  (toggle-cursor-type-when-idle 1))
#+end_src
** COMMENT Evil mode
#+begin_src emacs-lisp
(use-package evil
  :demand t
  :bind (("<escape>" . keyboard-escape-quit))
  :init
  ;; allows for using cgn
  ;; (setq evil-search-module 'evil-search)
  (setq evil-want-keybinding nil)
  ;; no vim insert bindings
  (setq evil-undo-system 'undo-fu)
  :config
  (evil-mode 1))

(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))
#+end_src
* Enhancement
** Ediff
#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally)
#+end_src
** Uniquify
#+begin_src emacs-lisp
  ;; Every buffer should have a unique name 
  (require 'uniquify)
  (setq
   uniquify-buffer-name-style 'post-forward
   uniquify-separator ":")
#+end_src
** Hippie expand
#+begin_src emacs-lisp
  ;; hippie expand is dabbrev expand on steroids
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))
  (global-set-key (kbd "M-/") 'hippie-expand)
#+end_src
** Smartscan
=M-n= to next symbol, and =M-p= to previous symbol.
Only in elisp and c mode.
#+begin_src emacs-lisp
(use-package smartscan
  :config
  (add-hook 'emacs-lisp-mode-hook 'smartscan-mode)
  (add-hook 'c-mode-hook 'smartscan-mode))
#+end_src
** Hungry delete
#+begin_src emacs-lisp
  (use-package hungry-delete
    :config
    (global-hungry-delete-mode))
#+end_src
** Unfill paragraph
#+begin_src emacs-lisp
  ;;; Stefan Monnier <foo at acm.org>. It is the opposite of
  ;;; fill-paragraph
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))
  ;; Handy key definition
  (define-key global-map "\M-Q" 'unfill-paragraph)
#+end_src
** Smart move to the beginning of line
#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC
** Window operation
#+BEGIN_SRC emacs-lisp
(defun my/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (if (= prefix 1)
      (switch-to-next-buffer)))
(defun my/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (if (= prefix 1) (switch-to-next-buffer)))

(global-set-key (kbd "C-x 2") 'my/vsplit-last-buffer)
(global-set-key (kbd "C-x 3") 'my/hsplit-last-buffer)

(defun sanityinc/toggle-delete-other-windows ()
  "Delete other windows in frame if any, or restore previous window config."
  (interactive)
  (if (and winner-mode
           (equal (selected-window) (next-window)))
      (winner-undo)
    (delete-other-windows)))

(global-set-key (kbd "C-x 1") 'sanityinc/toggle-delete-other-windows)

(defun split-window-horizontally-instead (prefix)
    (interactive "p")
    (delete-other-windows)
    (split-window-horizontally)
    (let ((target-window (next-window)))
                   (set-window-buffer target-window (other-buffer))))

(defun split-window-vertically-instead (prefix)
    (interactive "p")
    (delete-other-windows)
    (split-window-vertically)
    (let ((target-window (next-window)))
                   (set-window-buffer target-window (other-buffer))))

(global-set-key (kbd "C-x |") 'split-window-horizontally-instead)
(global-set-key (kbd "C-x _") 'split-window-vertically-instead)
#+END_SRC
** Smart copy/kill
#+begin_src emacs-lisp
;; Smart copy, if no region active, it simply copy the current whole line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode js-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))

(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive (if mark-active (list (region-beginning) (region-end))
                 (message "Copied line")
                 (list (line-beginning-position)
                       (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defun get-point (symbol &optional arg)
  "get the point"
  (funcall symbol arg)
  (point)
  )

(defun copy-thing (begin-of-thing end-of-thing &optional arg)
  "copy thing between beg & end into kill ring"
  (save-excursion
    (let ((beg (get-point begin-of-thing 1))
          (end (get-point end-of-thing arg)))
      (copy-region-as-kill beg end)))
  )

(defun copy-word (&optional arg)
  "Copy words at point into kill-ring"
  (interactive "P")
  (copy-thing 'subword-backward 'subword-forward arg)
  ;;(paste-to-mark arg)
  )

(global-set-key (kbd "C-c w") (quote copy-word))
#+end_src
** ibuffer-vc
#+begin_src emacs-lisp
  (use-package ibuffer-vc
    :config
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                filename-and-process))))
#+end_src
** narrow-or-widen-dwim
   #+BEGIN_SRC emacs-lisp
     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens. Otherwise, it narrows
     intelligently.  Intelligently means: region, org-src-block,
     org-subtree, or defun, whichever applies first.  Narrowing to
     org-src-block actually calls `org-edit-src-code'.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((and (boundp 'org-src-mode) org-src-mode (not p))
              (org-edit-src-exit))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode)
              (cond ((ignore-errors (org-edit-src-code)))
                    ((org-at-block-p)
                     (org-narrow-to-block))
                    (t (org-narrow-to-subtree))))
             ((derived-mode-p 'prog-mode) (narrow-to-defun))
             (t (error "Please select a region to narrow to"))))

     (global-set-key (kbd "C-x n n") 'narrow-or-widen-dwim)

   #+END_SRC


** Dired
#+begin_src emacs-lisp
(setq
 dired-dwim-target t            ; if another Dired buffer is visibpple in another window, use that directory as target for Rename/Copy
 dired-recursive-copies 'always         ; "always" means no asking
 dired-recursive-deletes 'top           ; "top" means ask once for top level directory
 dired-listing-switches "-lha"          ; human-readable listing
 ls-lisp-dirs-first t
 )
(use-package dired-filetype-face)

;; auto refresh dired when file changes
(add-hook 'dired-mode-hook 'auto-revert-mode)

(with-eval-after-load 'dired  (require 'dired-filetype-face))
#+end_src

* Extensions
** ace-window
#+begin_src emacs-lisp
(use-package ace-window
  :bind ("C-x o" . ace-window))
#+end_src
** beacon-mode
Never to lose your cursor again.
#+begin_src emacs-lisp
  (use-package beacon
    :diminish beacon-mode
    :init
    (beacon-mode 1)
    (setq beacon-push-mark 35)
    (setq beacon-color "#666600"))
#+end_src
** Rainbow delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :defer t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Expand region
#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

** Key frequency
#+begin_src emacs-lisp
  (use-package keyfreq
    :init
    :config
    (setq keyfreq-excluded-commands
          '(self-insert-command
            abort-recursive-edit
            forward-char
            backward-char
            previous-line
            next-line))
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src
** Olivetti (for prose writing)
#+begin_src emacs-lisp
;; Minor mode for a nice writing environment
(use-package olivetti
  :defer t
  :bind ("C-c o" . olivetti-mode)
  :config)
#+end_src

** Word count
#+begin_src emacs-lisp
  (use-package wc-mode)
#+end_src
** Multiple cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :bind (;("C-M" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+end_src
** Smart comment
   #+begin_src emacs-lisp
   (use-package comment-dwim-2
     :bind ("M-;" . comment-dwim-2))
   #+end_src
** Auto completion

#+begin_src emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode
  :init
  (use-package company-flx)
  (global-company-mode 1)
  (setq company-backends (delete 'company-semantic company-backends))
  (add-to-list 'company-backends 'company-c-headers)
  (add-to-list 'company-backends 'company-clang)
  (with-eval-after-load 'company
    (company-flx-mode +1))
  
  :config
  (bind-keys :map company-active-map
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous)
             ("C-d" . company-show-doc-buffer)
             ("<tab>" . company-complete)))

(use-package company-org-block
  :ensure t
  :custom
  (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
  :hook ((org-mode . (lambda ()
                       (setq-local company-backends '(company-org-block))
                       (company-mode +1)))))


#+end_src

#+begin_src emacs-lisp :lexical no
(use-package company-c-headers
  :config
  (add-to-list 'company-backends 'company-c-headers))
#+end_src
To retrive candidates for your projects, you will have to tell Clang
where your include paths are, create a file named =.dir-local.el= at
your project root:
#+BEGIN_SRC emacs-lisp :tangle no
  ((nil . ((company-clang-arguments . ("-I/home/<user>/project_root/include1/"
                                       "-I/home/<user>/project_root/include2/")))))
#+END_SRC

#+begin_src emacs-lisp :lexical no
(use-package company-english-helper
  :straight (:host github :repo "manateelazycat/company-english-helper")
  :config (setq company-english-helper-fuzz-search-p t))
#+end_src

#+begin_src emacs-lisp :tangle no
;; Modular text completion framework
(use-package corfu
  :init
  (global-corfu-mode 1)
  (corfu-popupinfo-mode 1)
  :config
  (setq corfu-cycle t
        corfu-auto t
        corfu-auto-delay 0
        corfu-auto-prefix 2
        corfu-quit-at-boundary 'separator
        corfu-popupinfo-delay 0.5))
;; Emacs completion style that matches multiple regexps in any order
(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic partial-completion)
        completion-category-overrides '((file (styles basic partial-completion)))
        orderless-component-separator "[ |]"))
#+end_src
** COMMENT Input method
#+begin_src emacs-lisp :lexical no
(use-package rime
  :custom
  (default-input-method "rime"))
#+end_src
* Program
** cc-mode
#+begin_src emacs-lisp
(defun linux-c-mode()
  (define-key c-mode-map [return] 'newline-and-indent)
  (interactive)
  (c-set-style "K&R")
  (c-toggle-auto-state)
  (setq c-basic-offset 8)
  (setq indent-tabs-mode nil)
  (c-toggle-hungry-state)
  (imenu-add-menubar-index)
  (which-function-mode)
  (c-toggle-auto-newline 1)
  (c-set-offset 'inextern-lang 0)
  )

(defun linux-cpp-mode()
  (define-key c++-mode-map [return] 'newline-and-indent)
  (define-key c++-mode-map [(control c) (c)] 'compile)
  (interactive)
  (c-set-style "K&R")
  (c-toggle-auto-state)
  (c-toggle-hungry-state)

  (setq c++-tab-always-indent t)
  (setq c-basic-offset 4)
  (setq indent-tabs-mode nil)
  (imenu-add-menubar-index)
  (which-function-mode)
  (c-set-offset 'inextern-lang 0))

(add-hook 'c-mode-hook 'linux-c-mode)
(add-hook 'c++-mode-hook 'linux-cpp-mode)
(add-hook 'c++-ts-mode-hook 'linux-cpp-mode)

(use-package color-identifiers-mode
  :config
  (add-hook 'c-mode-hook 'color-identifiers-mode)
  (add-hook 'c++-mode-hook 'color-identifiers-mode)
  (add-hook 'c++-ts-mode-hook 'color-identifiers-mode))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package modern-cpp-font-lock
  :diminish t
  :init (modern-c++-font-lock-global-mode t))
#+end_src
** Cmake
#+begin_src emacs-lisp :lexical no
(use-package cmake-mode :defer t)
#+end_src
** Web mode
#+begin_src emacs-lisp :lexical no
(use-package web-mode
  :custom-face
  (css-selector ((t (:inherit default :foreground "#66CCFF"))))
  :mode
  ("\\.phtml\\'" "\\.tpl\\.php\\'" "\\.[agj]sp\\'" "\\.as[cp]x\\'"
   "\\.erb\\'" "\\.mustache\\'" "\\.djhtml\\'" "\\.[t]?html?\\'"))
#+end_src
** Json mode
#+begin_src emacs-lisp :lexical no
(use-package json-mode
  :mode "\\.json\\'")
#+end_src
** Makefile
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("[Mm]akefile*" . makefile-gmake-mode))
(defun prelude-makefile-mode-defaults ()
  (setq indent-tabs-mode t ))

(setq prelude-makefile-mode-hook 'prelude-makefile-mode-defaults)

(add-hook 'makefile-mode-hook (lambda ()
                                (run-hooks 'prelude-makefile-mode-hook)))
#+END_SRC

** Markdown
#+begin_src emacs-lisp
;; Emacs Major mode for Markdown-formatted files
(use-package markdown-mode
  :defer t)
#+end_src
** dtrt-indent
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent)
(add-hook 'c-mode-common-hook
          (lambda()
            (require 'dtrt-indent)
            ;; (setq dtrt-indent-verbosity 0)
            (dtrt-indent-mode t)))
#+END_SRC
** Aggressive indent
   #+begin_src emacs-lisp
   (use-package aggressive-indent
     :config
     (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
     (add-hook 'c-mode-hook #'aggressive-indent-mode)
     (add-hook 'c++-mode-hook #'aggressive-indent-mode)
     (add-hook 'c++-ts-mode-hook #'aggressive-indent-mode)
     (add-hook 'css-mode-hook #'aggressive-indent-mode))
   #+end_src
   #+begin_src emacs-lisp :lexical no
   (use-package indent-guide
     :config
     (indent-guide-global-mode)
     (set-face-background 'indent-guide-face "dimgray")
     (setq indent-guide-char " ")
     )
   #+end_src
** Clear trailing spaces automatically
#+begin_src emacs-lisp :lexical no
(use-package ws-butler
  :config
  (add-hook 'prog-mode-hook #'ws-butler-mode))
#+end_src
** Fly spell
#+begin_src emacs-lisp
(defun cycle-languages ()
  "Changes the ispell dictionary to the first element in
ISPELL-LANGUAGES, and returns an interactive function that cycles
the languages in ISPELL-LANGUAGES when invoked."
  (let ((ispell-languages (list "american" "norsk")))
    (lambda ()
      (interactive)
      ;; Rotates the languages cycle and changes the ispell dictionary.
      (let ((rotated (nconc (cdr ispell-languages) (list (car ispell-languages)))))
        (ispell-change-dictionary (car (setq ispell-languages rotated)))))))

(use-package flyspell
  :defer t
  :if (executable-find "aspell")
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode)
         (flyspell-mode . (lambda ()
                            (local-set-key
                             (kbd "C-c f")
                             (cycle-languages)))))
  :config
  (ispell-change-dictionary "american" t))
#+end_src
** Magit
#+begin_src emacs-lisp
;; A Git porcelain inside Emacs.
(use-package magit
  :bind ("C-x g" . magit-status))

(use-package git-timemachine)
#+end_src
** Git gutter
   #+begin_src emacs-lisp
   (use-package git-gutter
     :config
     (setq git-gutter:update-interval 0.02)
     (global-git-gutter-mode +1))

   (use-package git-gutter-fringe
     :config
     (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
     (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
     (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
   #+end_src
** Helm
*** Basic settings
#+begin_src emacs-lisp
(use-package helm
  :ensure t
  :config
  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t)

  :bind (("C-c h" . helm-command-prefix)
         ("M-x" . helm-M-x)
         ("C-x y" . helm-show-kill-ring)
         ("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("M-i" . helm-occur)
         :map helm-command-map
         ("C-i" . helm-execute-persistent-action)
         ("C-i" . helm-select-action)
         ("<tab>" . helm-execute-persistent-action))
  )

(global-unset-key (kbd "C-x c"))
#+end_src
*** Helm gtags
#+begin_src emacs-lisp
(use-package helm-gtags
  :after helm
  :config
  (setq helm-gtags-auto-update t)
  (setq helm-gtags-update-interval-second 60)
  :bind (:map helm-gtags-mode-map
              ("M-t" . helm-gtags-find-tag)
              ("M-r" . helm-gtags-find-rtag)
              ("M-s" . helm-gtags-find-symbol)
              ("M-g M-p" . helm-gtags-parse-file)
              ("C-c <" . helm-gtags-previous-history)
              ("C-c >" . helm-gtags-next-history)
              ("M-," . helm-gtags-pop-stack))
  :hook ((c-mode-hook . helm-gtags-mode)
         (c++-mode-hook . helm-gtags-mode)
         (c++-ts-mode-hook . helm-gtags-mode)
         (asm-mode-hook . helm-gtags-mode)))
#+end_src
*** Helm rtags
#+begin_src emacs-lisp
(use-package helm-rtags)
#+end_src
*** Helm projectile
#+begin_src emacs-lisp
(use-package helm-projectile
  :diminish t
  :after helm
  :bind (("C-c p f" . helm-projectile-find-file-dwim)
         ("C-c p p" . helm-projectile-switch-project)
         ("C-c p b" . helm-projectile-switch-to-buffer)
         ("C-c p g" . helm-projectile-grep)))

(projectile-global-mode)
(setq projectile-completion-system 'helm)
(helm-projectile-on)

(setq projectile-enable-caching t)
#+end_src
*** Helm exwm
#+begin_src emacs-lisp
(use-package helm-exwm
  :ensure t
  :bind ("C-x B" . helm-exwm)
  :config
  (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
  (setq helm-exwm-source (helm-exwm-build-source))
  (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                    helm-exwm-source
                                    helm-source-recentf)))
#+end_src
*** helm-ag
    Rely on =ripgrep=, install it firstly.
 #+begin_src emacs-lisp
 (use-package helm-ag
   :init
   (setq helm-ag-base-command "rg"
         helm-ag-command-option "--no-heading -i"
         helm-ag-insert-at-point 'symbol)
   :bind
   ("C-c h g" . helm-do-ag)
 )
 #+end_src
** COMMENT Ivy
#+begin_src emacs-lisp :lexical no
(use-package ivy :ensure t
  :diminish (ivy-mode . "")
  :bind
  (:map ivy-mode-map
        ("C-'" . ivy-avy))
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	    ;; allow input not in order
        '((t   . ivy--regex-ignore-order))))
#+end_src
** Yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :diminish t
  :init
  (setq helm-yas-space-match-any-greedy t)
  (setq yas-prompt-functions '(yas-dropdown-prompt
                               yas-ido-prompt
                               yas-completing-prompt))
  :config
  (use-package helm-c-yasnippet)
  (yas-global-mode 1)
  (add-hook 'term-mode-hook (lambda()
                              (yas-minor-mode -1))))
#+end_src

** Compilation
#+begin_src emacs-lisp
(defun prelude-colorize-compilation-buffer ()
  "Colorize a compilation mode buffer."
  (interactive)
  ;; we don't want to mess with child modes such as grep-mode, ack, ag, etc
  (when (eq major-mode 'compilation-mode)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max)))))
(setq compilation-ask-about-save nil          ; Just save before compiling
      compilation-always-kill t               ; Just kill old compile processes before starting the new one
      compilation-scroll-output 'first-error) ; Automatically scroll to first
(use-package cd-compile
  :bind ("<f5>" . cd-compile))
#+end_src

** Smartparens
#+begin_src emacs-lisp
(use-package smartparens-mode
  :ensure smartparens  ;; install the package
  :hook (prog-mode text-mode markdown-mode) ;; add `smartparens-mode` to these hooks
  :config
  ;; load default config
  (require 'smartparens-config))
#+end_src

** Tree sit auto
#+begin_src emacs-lisp :lexical no
(use-package treesit-auto
  :demand t
  :config
  (setq treesit-auto-install 'prompt)
  (global-treesit-auto-mode))
#+end_src

** Eglot
#+begin_src emacs-lisp :lexical no
(use-package eglot
  :defer t
  :config
  (add-hook 'c-ts-mode-hook #'eglot-ensure)
  (add-hook 'c++-mode-hook #'eglot-ensure)
  (add-hook 'c++-ts-mode-hook #'eglot-ensure))
#+end_src
** COMMENT Lsp mode
#+begin_src emacs-lisp :lexical no
(use-package lsp-mode
  :defer t
  :commands lsp
  :custom
  (lsp-keymap-prefix "C-x l")
  (lsp-auto-guess-root nil)
  (lsp-prefer-flymake nil) ; Use flycheck instead of flymake
  (lsp-enable-file-watchers nil)
  (lsp-enable-folding nil)
  (read-process-output-max (* 1024 1024))
  (lsp-keep-workspace-alive nil)
  (lsp-eldoc-hook nil)
  :bind (:map lsp-mode-map ("C-c C-f" . lsp-format-buffer))
  :hook ((java-mode python-mode go-mode rust-mode
                    js-mode js2-mode typescript-mode web-mode
                    c-mode c++-mode objc-mode) . lsp-deferred)
  :config
  (defun lsp-update-server ()
    "Update LSP server."
    (interactive)
    ;; Equals to `C-u M-x lsp-install-server'
    (lsp-install-server t)))
#+end_src

** TODO COMMENT Editor config
#+begin_src emacs-lisp
  ;; EditorConfig Emacs Plugin
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src

* Org mode
** Basics
#+begin_src emacs-lisp
(use-package org
  :defer t
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         :map org-mode-map
         ("M-;" . org-comment-dwim))
  :config
  (setq org-adapt-indentation t
        org-hide-leading-stars t
        org-hide-emphasis-markers t
        org-src-fontify-natively t
        org-edit-src-content-indentation 0
        org-ellipsis "⤵")

  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  (add-hook 'org-mode-hook (lambda () (org-indent-mode t))))

#+end_src
** org-babel
#+begin_src emacs-lisp
(use-package gnuplot)
(use-package plantuml-mode)
;; active Babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (dot . t)
   (ditaa . t)
   (python . t)
   (gnuplot . t)
   (plantuml . t)
   (emacs-lisp . t)
   ))
;; Install plantuml.jar by: sudo apt install plantuml
(setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
(setq puml-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+end_src
** Plantuml
#+begin_src emacs-lisp
(use-package plantuml-mode
  :defer t
  :mode ("\\.\\(pum\\|puml\\)\\'" . plantuml-mode)
  :after ob
  :init
  (add-to-list 'org-babel-load-languages '(plantuml . t))
  :config
  (setq plantuml-default-exec-mode 'jar
        plantuml-jar-path "~/.local/bin/plantuml.jar"
        org-plantuml-jar-path "~/.local/bin/plantuml.jar"))
#+end_src
** Graphviz(dot)
#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :defer t
  :after org
  :mode (("\\.diag\\'"      . graphviz-dot-mode)
         ("\\.blockdiag\\'" . graphviz-dot-mode)
         ("\\.nwdiag\\'"    . graphviz-dot-mode)
         ("\\.rackdiag\\'"  . graphviz-dot-mode)
         ("\\.dot\\'"       . graphviz-dot-mode)
         ("\\.gv\\'"        . graphviz-dot-mode))
  :init
  (setq graphviz-dot-indent-width tab-width)
  (with-eval-after-load 'org
      (defalias 'org-babel-execute:graphviz-dot #'org-babel-execute:dot)
      (add-to-list 'org-babel-load-languages '(dot . t))
      (require 'ob-dot)
      (setq org-src-lang-modes
            (append '(("dot" . graphviz-dot))
                    (delete '("dot" . fundamental) org-src-lang-modes)))))

#+end_src
** COMMENT Org auto tangle
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Org modern
#+begin_src emacs-lisp
;; Modern looks for Org
(use-package org-modern
  :after org
  :hook
  (org-mode . org-modern-mode)
  :config
  (setq org-modern-block-fringe nil))
#+end_src
** org-journal
#+begin_src emacs-lisp
(use-package org-journal
  :init
  (setq org-journal-dir "~/org/journal/"
        org-journal-date-format "%A, %d %B %Y"
        org-journal-file-type 'weekly)
  :bind
  ("<f6>" . org-journal-new-entry))
#+end_src
** org-ai
#+begin_src emacs-lisp
(use-package org-ai
  :ensure t
  :commands (org-ai-mode
             org-ai-global-mode)
  :init
  (add-hook 'org-mode-hook #'org-ai-mode) ; enable org-ai in org-mode
  (org-ai-global-mode) ; installs global keybindings on C-c M-a
  :config
  (setq org-ai-default-chat-model "gpt-3.5-turbo") ; if you are on the gpt-4 beta:
  (org-ai-install-yasnippets)) ; if you are using yasnippet and want `ai` snippets
#+end_src

** org-download
#+begin_src emacs-lisp
(use-package org-download
    :after org
    :bind
    (:map org-mode-map
    (("s-Y" . org-download-screenshot)
        ("s-y" . org-download-yank)))
    :config
    (if (memq window-system '(mac ns))
        (setq org-download-screenshot-method "screencapture -i %s")
        (setq org-download-screenshot-method "flameshot gui --raw > %s")
        )
    (defun my-org-download-method (link)
        "This is a helper function for org-download.
    It creates a folder in the root directory (~/.org/img/) named after the
    org filename (sans extension) and puts all images from that file in there.
    Inspired by https://github.com/daviderestivo/emacs-config/blob/6086a7013020e19c0bc532770e9533b4fc549438/init.el#L701"
        (let ((filename
            (file-name-nondirectory
                (car (url-path-and-query
                    (url-generic-parse-url link)))))
            ;; Create folder name with current buffer name, and place in root dir
            (dirname (concat "./images/"
                            (replace-regexp-in-string " " "_" (downcase (file-name-base buffer-file-name))))))

        ;; Add timestamp to filename
        (setq filename-with-timestamp (format "%s%s.%s"
                                                (file-name-sans-extension filename)
                                                (format-time-string org-download-timestamp)
                                                (file-name-extension filename)))
        ;; Create folder if necessary
        (unless (file-exists-p dirname)
            (make-directory dirname t))
        (expand-file-name filename-with-timestamp dirname)))
    (setq org-download-method 'my-org-download-method))
#+end_src

** COMMENT org-capture
#+begin_src emacs-lisp
;; Org-capture templates
(setq org-my-anki-file "~/org/capture/anki.org")

(setq org-capture-templates
      '(
        ("a" "Anki basic"
         entry
         (file+headline org-my-anki-file "Dispatch Shelf")
         "* %<%H:%M>   %^g\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Basic\n:ANKI_DECK: Mega\n:END:\n** Front\n%?\n** Back\n%x\n")
        ("A" "Anki cloze"
         entry
         (file+headline org-my-anki-file "Dispatch Shelf")
         "* %<%H:%M>   %^g\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Cloze\n:ANKI_DECK: Mega\n:END:\n** Text\n%x\n** Extra\n")))
#+end_src
** org-roam
#+begin_src emacs-lisp
;; Copy from https://ag91.github.io/blog/2022/02/05/an-helm-source-for-org-roam-v2/
(defun helm-org-roam (&optional input candidates)
  (interactive)
  (require 'org-roam)
  (helm
   :input input
   :sources (list
             (helm-build-sync-source "Roam: "
               :must-match nil
               :fuzzy-match t
               :candidates (or candidates (org-roam--get-titles))
               :action
               '(("Find File" . (lambda (x)
                                  (--> x
                                       org-roam-node-from-title-or-alias
                                       (org-roam-node-visit it t))))
                 ("Insert link" . (lambda (x)
                                    (--> x
                                         org-roam-node-from-title-or-alias
                                         (insert
                                          (format
                                           "[[id:%s][%s]]"
                                           (org-roam-node-id it)
                                           (org-roam-node-title it))))))
                 ("Follow backlinks" . (lambda (x)
                                         (let ((candidates
                                                (--> x
                                                     org-roam-node-from-title-or-alias
                                                     org-roam-backlinks-get
                                                     (--map
                                                      (org-roam-node-title
                                                       (org-roam-backlink-source-node it))
                                                      it))))
                                           (helm-org-roam nil (or candidates (list x))))))))
             (helm-build-dummy-source
                 "Create note"
               :action '(("Capture note" . (lambda (candidate)
                                             (org-roam-capture-
                                              :node (org-roam-node-create :title candidate)
                                              :props '(:finalize find-file)))))))))

(defun org-roam-tag-add-non-interactive (tags)
  "Add TAGS to the node at point."
  (let ((node (org-roam-node-at-point 'assert)))
    (goto-char (org-roam-node-point node))
    (if (= (org-outline-level) 0)
        (let ((current-tags (split-string (or (cadr (assoc "FILETAGS"
                                                           (org-collect-keywords '("filetags"))))
                                              "")
                                          ":" 'omit-nulls)))
          (org-roam-set-keyword "filetags" (org-make-tag-string (seq-uniq (append tags current-tags)))))
      (org-set-tags (seq-uniq (append tags (org-get-tags)))))))

(defun helm-org-roam-tag (&optional input candidates)
  (interactive)
  (require 'org-roam)
  (helm
   :input input
   :sources (list
             (helm-build-sync-source "Roam: "
               :must-match nil
               :fuzzy-match t
               :candidates (or candidates (org-roam-tag-completions))
               :action
               '(("Add tag" . (lambda (candidate)
                                (org-roam-tag-add-non-interactive (list candidate))
                                ))))
             (helm-build-dummy-source
                 "Create tag"
               :action '(("New tag" . (lambda (candidate)
                                        (org-roam-tag-add-non-interactive (list candidate))
                                        )))))))

(use-package org-roam
  :ensure t
  :init
  (when (file-directory-p "~/org/roam/")
    (setq org-roam-directory (file-truename "~/org/roam")))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ("C-c n t" . helm-org-roam-tag)
         ("C-c n T" . org-roam-tag-remove)
         ("C-c n o" . helm-org-roam)
         ;; Dailies
         ("C-c n j" . org-roam-dailies-capture-today))
  :config
  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-mode)
  ;; If using org-roam-protocol
  (require 'org-roam-protocol))
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
  :bind ("<f6>" . deft)
  :config
  (setq deft-directory "~/org/roam/"
        deft-recursive t
        deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
        deft-extensions '("md" "org")
        deft-use-filename-as-title t))
#+end_src
*** org-roam-ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src
*** TODO COMMENT Nersery
#+begin_src emacs-lisp :lexical no
(use-package nursery
  :straight (:host github :repo "chrisbarrett/nursery")
  )

(use-package org-roam-review
  :commands (org-roam-review
             org-roam-review-list-by-maturity
             org-roam-review-list-recently-added)

  ;; ;; Optional - tag all newly-created notes as seedlings.
  ;; :hook (org-roam-capture-new-node . org-roam-review-set-seedling)

  ;; ;; Optional - keybindings for applying Evergreen note properties.
  ;; :general
  ;; (:keymaps 'org-mode-map
  ;; "C-c r r" '(org-roam-review-accept :wk "accept")
  ;; "C-c r u" '(org-roam-review-bury :wk "bury")
  ;; "C-c r x" '(org-roam-review-set-excluded :wk "set excluded")
  ;; "C-c r b" '(org-roam-review-set-budding :wk "set budding")
  ;; "C-c r s" '(org-roam-review-set-seedling :wk "set seedling")
  ;; "C-c r e" '(org-roam-review-set-evergreen :wk "set evergreen"))

  ;; ;; Optional - bindings for evil-mode compatability.
  ;; :general
  ;; (:states '(normal) :keymaps 'org-roam-review-mode-map
  ;; "TAB" 'magit-section-cycle
  ;; "g r" 'org-roam-review-refresh)
  )

(use-package org-roam-search
  :commands (org-roam-search))

(use-package org-roam-links
  :commands (org-roam-links))

(use-package org-roam-dblocks
  :hook (org-mode . org-roam-dblocks-autoupdate-mode))

(use-package org-roam-rewrite
  :commands (org-roam-rewrite-rename
             org-roam-rewrite-remove
             org-roam-rewrite-inline
             org-roam-rewrite-extract))

(use-package org-roam-slipbox
  :after org-roam
  :demand t
  :config
  (org-roam-slipbox-buffer-identification-mode +1)
  (org-roam-slipbox-tag-mode +1))
#+end_src
** Org transclusion
#+begin_src emacs-lisp :lexical no
(use-package org-transclusion
  :after org
  :bind
  (:map org-mode-map
        ("<f12>" . org-transclusion-mode)))
#+end_src

** Org hugo
#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox)
#+end_src

** org-fragtog(preview latex online)
#+begin_src emacs-lisp :lexical no
(use-package org-fragtog
  :config
  (add-hook 'org-mode-hook 'org-fragtog-mode))
#+end_src
** Latex
#+begin_src emacs-lisp
(require 'ox-latex)
(require 'ox-beamer)
(setq org-latex-images-centered 't)

(setq org-latex-coding-system 'utf-8)

(setf org-latex-default-packages-alist
      (remove '("AUTO" "inputenc" t) org-latex-default-packages-alist))
(setf org-latex-default-packages-alist
      (remove '("T1" "fontenc" t) org-latex-default-packages-alist))
(setf org-latex-default-packages-alist
      (remove '("" "hyperref" nil) org-latex-default-packages-alist))
(setq org-latex-with-hyperref nil)

(setq org-latex-pdf-process '("xelatex -8bit -shell-escape  %f"
                              "xelatex -8bit -shell-escape  %f"))
;; (setq org-latex-packages-alist
;;       '("
;;         \\hypersetup{ colorlinks,% 
;;                 linkcolor=blue,% 
;;                 citecolor=black,%
;;                 urlcolor=black,%
;;                 filecolor=black
;;                }

;;         \\usepackage{array}
;;         \\usepackage{xcolor}
;;         \\definecolor{bg}{rgb}{0.95,0.95,0.95}"))

(add-to-list 'org-latex-packages-alist '("" "minted")) 
(setq org-latex-listings 'minted)
(setq org-latex-minted-options
      '(
        ("bgcolor" "bg")
        ("frame" "lines")
        ("linenos" "")
        ("fontsize" "\\scriptsize")
        ))

(add-to-list 'org-latex-classes
             '("article-cn"
              "\\documentclass[11pt]{article}
                [DEFAULT-PACKAGES]
                [PACKAGES]
                \\usepackage{fontspec}

                \\XeTeXlinebreaklocale ``zh''
                \\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
                \\newcommand\\fontnamehei{WenQuanYi Zen Hei}
                \\newcommand\\fontnamesong{AR PL UMing CN}
                \\newcommand\\fontnamekai{AR PL KaitiM GB}
                \\newcommand\\fontnamemono{FreeMono}
                \\newcommand\\fontnameroman{FreeSans}
                \\setmainfont[BoldFont=\\fontnamehei]{\\fontnamesong}
                \\setsansfont[BoldFont=\\fontnamehei]{\\fontnamekai}
                \\setmonofont{\\fontnamemono}
                \\setromanfont[BoldFont=\\fontnamehei]{\\fontnamesong}
                \\makeatletter
                \\def\\verbatim@font{\\rmfamily\\small} %verbatim中使用roman字体族
                \\makeatother"

              ("\\section{%s}" . "\\section*{%s}")
              ("\\subsection{%s}" . "\\subsection*{%s}")
              ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
              ("\\paragraph{%s}" . "\\paragraph*{%s}")
              ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
             '("article-img"
              "\\documentclass[11pt]{article}
                [DEFAULT-PACKAGES]
                [PACKAGES]
                \\usepackage{geometry}
                \\geometry{left=1.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm}"
              ("\\section{%s}" . "\\section*{%s}")
              ("\\subsection{%s}" . "\\subsection*{%s}")
              ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
              ("\\paragraph{%s}" . "\\paragraph*{%s}")
              ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
(add-to-list 'org-latex-classes
             '("letter"
               "\\documentclass{letter}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ))
#+end_src
** auctex
#+begin_src emacs-lisp :lexical no
(use-package tex
  :ensure auctex
  :defer t
  :custom
  (TeX-auto-save t)
  (TeX-parse-self t)
  (TeX-master nil)
  ;; to use pdfview with auctex
  (TeX-view-program-selection '((output-pdf "pdf-tools"))
                              TeX-source-correlate-start-server t)
  (TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
  (TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  :hook
  (LaTeX-mode . (lambda ()
                  (turn-on-reftex)
                  (setq reftex-plug-into-AUCTeX t)
                  (reftex-isearch-minor-mode)
                  (setq TeX-PDF-mode t)
                  (setq TeX-source-correlate-method 'synctex)
                  (setq TeX-source-correlate-start-server t)))
  :config
  (when (version< emacs-version "26")
    (add-hook LaTeX-mode-hook #'display-line-numbers-mode)))
#+end_src
* Shells
** Eshell
#+begin_src emacs-lisp
(setq eshell-scroll-to-bottom-on-input t) ; press any key to jump back to the prompt:
(setq eshell-prefer-lisp-functions nil)
#+end_src
** Exec-path-from-shell
#+begin_src emacs-lisp :lexical no
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns x))
  :config
  (exec-path-from-shell-initialize))



#+end_src
* Exwm
#+begin_src emacs-lisp
(defun exwm/run-in-background (command &optional once)
  (let ((command-parts (split-string command " +")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

(use-package exwm
  :if (seq-contains-p command-line-args "--with-exwm")
  :config
  (set-frame-parameter (selected-frame) 'alpha-background 0.7)
  (require 'exwm-randr)
  ;; (exwm/run-in-background "feh --bg-scale \"${cat $HOME/Pictures/wall-paper.jpg}\"")
  (start-process-shell-command
   "xrandr" nil "xrandr --output eDP --mode 1920x1200")

  ;; Emacs server is not required to run EXWM but it has some interesting uses
  (server-start)

  (require 'exwm-config)
  ;; Set the initial workspace number.
  (unless (get 'exwm-workspace-number 'saved-value)
    (setq exwm-workspace-number 2))
  ;; Make class name the buffer name
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
  ;; Global keybindings.
  (unless (get 'exwm-input-global-keys 'saved-value)
    (setq exwm-input-global-keys
          `(
            ;; 's-r': Reset (to line-mode).
            ([?\s-R] . exwm-restart)
            ;; 's-w': Switch workspace.
            ([?\s-w] . exwm-workspace-switch)
            ;; 's-1': Switch workspace.
            ([?\s-1] . (exwm-workspace-switch 0))
            ;; 's-d': Launch application.
            ([?\s-d] . dmenu))))

            ;; ;; 's-N': Switch to certain workspace.
            ;; ,@(mapcar (lambda (i)
            ;;             `(,(kbd (format "s-%d" i)) .
            ;;               (lambda ()
            ;;                 (interactive)
            ;;                 (exwm-workspace-switch-create ,i))))
            ;;           (number-sequence 0 9))))
  ;; Line-editing shortcuts
  (unless (get 'exwm-input-simulation-keys 'saved-value)
    (setq exwm-input-simulation-keys
          '(([?\C-b] . [left])
            ([?\C-f] . [right])
            ([?\C-p] . [up])
            ([?\C-n] . [down])
            ([?\C-a] . [home])
            ([?\C-e] . [end])
            ([?\M-v] . [prior])
            ([?\C-v] . [next])
            ([?\C-d] . [delete])
            ([?\C-k] . [S-end delete]))))
  ;; Enable EXWM
  (exwm-enable)
  (exwm-randr-enable)
  (exwm-config-ido)
  (exwm-config-misc))
#+end_src
* Other tools

** Which key (show available keybindings)
#+begin_src emacs-lisp
;; Display available keybindings in popup
(use-package which-key
  :config
  (which-key-mode 1))
#+end_src
** Pdf tools
   #+begin_src emacs-lisp
   (use-package pdf-tools
     :config
     (pdf-tools-install))
   (use-package org-noter)
   #+end_src

** Dictionary & popweb
#+begin_src emacs-lisp :lexical no
(use-package popweb
  ;; :straight (:host github :repo "manateelazycat/popweb"
                   ;; :branch "main")
  :load-path (lambda () (expand-file-name "extension/popweb" user-emacs-directory))
  )

(use-package popweb-dict
  :load-path "extension/popweb/extension/dict"
  :bind ("C-c d" . popweb-dict-collins-input)

  :config
  (popweb-dict-create "collins"
                      "https://www.collinsdictionary.com/dictionary/english/%s"
                      (concat
                       "window.scrollTo(0, 390); "
                       "document.getElementsByClassName('navigation')[0].style.display = 'none'; "
                       "document.getElementsByTagName('body')[0].style.margin = '0'; "
                       "document.getElementsByTagName('header')[0].style.display = 'none'; "
                       "document.getElementsByTagName('footer')[0].style.display = 'none'; "
                       "document.getElementsByClassName('search')[0].style.display = 'none'; "
                       "document.getElementsByClassName('page')[0].style.visibility = 'visible' ; "
                       "document.getElementsByClassName('page')[0].style.margin = '0' ; "
                       "document.getElementsByClassName('padding-hub')[0].style.visibility = 'hidden' ; "
                       "document.getElementsByClassName('padding-hub')[0].style.margin = '0' ; "

                       "Array.from(document.querySelectorAll('ins')).forEach(e => { e.style.display = 'none' }); "
                       "Array.from(document.querySelectorAll('iframe:not(#player)')).forEach(e => { e.style.display = 'none' }); "
                       )))
#+end_src

#+begin_src emacs-lisp :tangle no
;; display the definition of word at point
(use-package sdcv
  :defer t
  :bind ("C-c d" . sdcv-search-input))
#+end_src

** Elfeed
#+begin_src emacs-lisp :lexical no
(use-package elfeed
  :bind ("C-x w" . elfeed)
  :config
  (use-package elfeed-goodies)
  ;; (setf url-queue-timeout 60)
  ;; (setf elfeed-curl-extra-arguments '("--socks5-hostname" "127.0.0.1:1080"))
  (elfeed-goodies/setup)
  (setq elfeed-feeds
        '(
          ("https://catcoding.me/atom.xml" blog)
          ("https://nullprogram.com/feed/" blog dev)
          ("https://nullprogram.com/feed/" blog dev)
          ("https://world.hey.com/dhh/feed.atom" blog)
          ("https://jvns.ca/atom.xml" blog)
          ("https://norvig.com/rss-feed.xml" blog)
          ))
  )
#+end_src
* COMMENT EAF
#+begin_src emacs-lisp
(use-package eaf
  :load-path (lambda () (expand-file-name "extension/emacs-application-framework" user-emacs-directory))
  :custom
  (eaf-start-python-process-when-require nil)
  (browse-url-browser-function #'eaf-open-browser) ;; Make EAF Browser my default browser
  (eaf-start-python-process-when-require t)
  (eaf-browser-dark-mode nil)
  (eaf-browser-enable-adblocker t)
  (eaf-webengine-continue-where-left-off t)
  (eaf-webengine-default-zoom 1.25)
  (eaf-webengine-scroll-step 200)
  (eaf-pdf-dark-mode "ignore")
  :demand
  :bind
  (
   ;; ("M-z r" . eaf-open-rss-reader)
   ;; ("M-m r" . eaf-open-rss-reader)
   ("M-#" . eaf-open-pyqterminal))
  :config
  ;; Require all EAF apps unconditionally, change to apps you're interested in.
  (require 'eaf-file-manager nil t)
  (require 'eaf-music-player nil t)
  (require 'eaf-image-viewer nil t)
  (require 'eaf-camera nil t)
  (require 'eaf-demo nil t)
  (require 'eaf-airshare nil t)
  (require 'eaf-markdown-previewer nil t)
  (require 'eaf-video-player nil t)
  (require 'eaf-vue-demo nil t)
  (require 'eaf-file-sender nil t)
  (require 'eaf-pdf-viewer nil t)
  (require 'eaf-mindmap nil t)
  (require 'eaf-netease-cloud-music nil t)
  (require 'eaf-jupyter nil t)
  (require 'eaf-org-previewer nil t)
  (require 'eaf-system-monitor nil t)
  (require 'eaf-rss-reader nil t)
  (require 'eaf-pyqterminal nil t)
  (require 'eaf-file-browser nil t)
  (require 'eaf-browser nil t)
  (require 'eaf-git nil t)
  (when (display-graphic-p)
    (require 'eaf-all-the-icons))
  (defalias 'browse-web #'eaf-open-browser)
  (eaf-bind-key nil "M-q" eaf-browser-keybinding)
  ;; (eaf-bind-key nil "M-z" eaf-browser-keybinding)
  (eaf-bind-key open_link "C-M-s" eaf-browser-keybinding)
  (eaf-bind-key open_devtools "M-i" eaf-browser-keybinding)
  (eaf-bind-key insert_or_recover_prev_close_page "X" eaf-browser-keybinding)
  (eaf-bind-key scroll_up "RET" eaf-pdf-viewer-keybinding)
  (eaf-bind-key delete_cookies "C-M-q" eaf-browser-keybinding)
  (eaf-bind-key delete_all_cookies "C-M-Q" eaf-browser-keybinding)
  (eaf-bind-key clear_history "C-M-p" eaf-browser-keybinding)
  (eaf-bind-key scroll_down_page "DEL" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down_page "u" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_up_page "d" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_to_end "M->" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_to_begin "M-<" eaf-pdf-viewer-keybinding)
  (eaf-bind-key quit-window "q" eaf-pdf-viewer-keybinding)
  (eaf-bind-key zoom_in "C-=" eaf-pdf-viewer-keybinding)
  (eaf-bind-key zoom_out "C--" eaf-pdf-viewer-keybinding)
  (eaf-bind-key take_photo "p" eaf-camera-keybinding))
#+end_src

#+begin_src emacs-lisp :lexical no
(use-package marginalia
  :ensure t
  :config
  (marginalia-mode))

(use-package embark
  :ensure t
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
  ;; strategy, if you want to see the documentation from multiple providers.
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
#+begin_src emacs-lisp :lexical no
(use-package ellama
  :init
  (setopt ellama-language "English")
  ;;(setopt ellama-language "Portuguese")
  (require 'llm-ollama)
  (setopt ellama-provider
          (make-llm-ollama
           :chat-model "mistral" :embedding-model "mistral")))
#+end_src
** leetcode
#+begin_src emacs-lisp :lexical no
(use-package leetcode
  :config
  (setq leetcode-prefer-language "cpp")
  (setq leetcode-save-solutions t)
  (setq leetcode-directory "~/gitest/org-samples/C++/leetcode/"))
#+end_src
